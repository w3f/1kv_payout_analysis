# title: "1kv Payout Analysis"
# author: "Jonas Gehrlein @ Web3 Foundation"
# date: 08/03/2022

library(tidyverse)
# Specify chain: either "polkadot" or "kusama"
chain = "kusama"
# Current era - 1 as the data is written at the end of an era
current_era = 3399
first_era = 3397

if(chain=="polkadot"){
  normalization = 1/10000000000
  stash_1kv <- c('14Ns6kKbCoka3MS4Hn6b7oRw9fFejG8RH5rq5j63cWUfpPDJ', '16GMHo9HZv8CcJy4WLoMaU9qusgzx2wxKDLbXStEBvt5274B', '12RYJb5gG4hfoWPK3owEYtmWoko8G6zwYpvDYTyXFVSfJr8Y')
  names_1kv <- c("1kv-stash-1", "1kv-stash-2", "1kv-stash-3")
}else{
  normalization = 1/1000000000000
  stash_1kv <- c('EX9uchmfeSqKTM7cMMg8DkH49XV8i4R7a7rqCn8btpZBHDP', 'G1rrUNQSk7CjjEmLSGcpNu72tVtyzbWdUvgmSer9eBitXWf', 'HgTtJusFEn2gmMmB5wmJDnMRXKD6dzqCpNR7a99kkQ7BNvX')
  names_1kv <- c("1kv-stash-1", "1kv-stash-2", "1kv-stash-3")
}

decode <- function(code) {
  # return a list of data frames for the decoded string vector code
  code %>% 
    str_split(",") %>% 
    map(str_split, ";", simplify = TRUE) %>% 
    map(as.data.frame) %>% 
    map(set_names, c("name", "value")) %>%
    map(~mutate_all(.,as.character)) %>%
    map(mutate, value = as.numeric(value))
}

sum_these <- function(df1, to_sum1) {
  # for one data frame of name, value (df1), sum the values for name in to_sum1
  df1 %>% filter(name %in% to_sum1) %>% pull(value) %>% as.numeric() %>% sum()
}

# Define the 1kv Stashes

info_1kv <- data.frame(stash_1kv, names_1kv)

difference = current_era - first_era
x = c(current_era:(current_era - difference))
# Loop through Era data at the end point. If one era is missing, it uses the one from before to fill the gap. That means, at least the first era needs to be non-missing.
for(i in 1:length(x)) {
  tryCatch(
    validators <- read.csv(url(paste("https://storage.googleapis.com/watcher-csv-exporter/", chain , "_validators_era_", x[i], ".csv", sep=(""))),stringsAsFactors = FALSE),
    validators_next <- read.csv(url(paste("https://storage.googleapis.com/watcher-csv-exporter/", chain , "_validators_era_", x[i] + 1, ".csv", sep=(""))),stringsAsFactors = FALSE),
    error = function(e){
      print("There was an Error")
      missing_validator <<- missing_validator + 1
      validators$era <<- validators$era + 1
    })
  validator_rewards <- validators_next$validator_rewards_previous_era[1]
  # Normalize values to DOT / KSM
  validators$self_stake <- validators$self_stake*normalization
  validators$total_stake <- validators$total_stake*normalization
  validator_rewards <- validator_rewards*normalization
  
  # Only take active validators
  validators <- subset(validators, active==1)
  
  # If a validator is 100% self-staked, it has empty staker list. I fix this here.
  validators$num_stakers <- ifelse(validators$stakers == "", 1, validators$num_stakers)
  validators$stakers <- ifelse(validators$stakers == "", paste(validators$stash_address, ";", validators$self_stake, sep=""), validators$stakers)
 
  # Set counter variable
  validators$votes_of_1kv <- 0
  validators$our_stash <- "none"
  validators$our_stash_name <- "none"
  
  # Loop to determine if one of the stash addresses is among the stakers, which essentially means that the validator is in 1kv
  for(t in 1:nrow(validators)){
    for(y in 1:length(stash_1kv)){
      find <- grepl(info_1kv$stash_1kv[y], validators$stakers[t])
      if(find==TRUE){
        validators$votes_of_1kv[t] <- validators$votes_of_1kv[t] + 1
        validators$our_stash[t] <- stash_1kv[y]
        validators$our_stash_name[t] <- names_1kv[y]
      }
    }
  }
  validators_use <- subset(validators, votes_of_1kv>=1)
  
  # Generate dataset which extracts the amount of our stake with the validator. In the case that more 1kv-stashes stake with a validator, we take the sum (this might never be the case)
  df <- tibble(
    validators_use$stash_address, validators_use$name, validators_use$commission_percent, validators_use$self_stake, validators_use$total_stake, validators_use$era_points, validators_use$our_stash, validators_use$our_stash_name,
    val = decode(validators_use$stakers), 
    to_sum = list(stash_1kv), 
    our_stake = map2_dbl(val, to_sum, sum_these)*normalization
  )
  # Create final data table
  df_output <- subset(df, select=c(`validators_use$stash_address`, `validators_use$name`,`validators_use$commission_percent`,`validators_use$total_stake`, `validators_use$self_stake`,`validators_use$era_points`,`validators_use$our_stash`, our_stake,`validators_use$our_stash_name`))
  colnames(df_output) <- c('stash_address', 'name', 'commission', 'total_stake', 'self_stake', 'era_points', 'our_stash', 'our_stake', 'our_stash_name')
  
  # Calculate our payoff (generated by our stashes) per validator
  df_output$our_payoff <- (df_output$era_points / sum(subset(validators, active==1)$era_points)) * validator_rewards * ((100-df_output$commission)/100) * (df_output$our_stake / df_output$total_stake)
  # Calculate overall payoff per validator
  df_output$total_payoff <- (df_output$era_points / sum(subset(validators, active==1)$era_points)) * validator_rewards
  df_aggregate <- aggregate(df_output$our_payoff, by=list(df_output$our_stash), FUN=sum)
  
  df_aggregate <- df_output %>%
    group_by(our_stash, our_stash_name) %>%
    summarise(sum(our_payoff), sum(our_stake))

  colnames(df_aggregate) <- c("our_stash", "our_stash_name", "our_payoff", "our_stake")
  df_aggregate <- subset(df_aggregate, select = c(our_stash_name, our_stash, our_stake, our_payoff))
  
  if(i==1){
    df_total_output <- df_output
    df_total_aggregate <- df_aggregate
  } else {
    df_total_output <- rbind(df_total_output, df_output)
    df_total_aggregate <- rbind(df_total_aggregate, df_aggregate)
  }
}

# Add a counter variable to later check how many times a validator was active
df_total_output$active <- 1

# Aggregate on validator level. We use average of era points per validator and sum of our payouts.
summary_validators <- df_total_output %>% 
  group_by(name, stash_address) %>% 
  summarise(sum(self_stake), sum(our_stake), sum(total_stake), sum(our_payoff), sum(total_payoff), mean(era_points), sum(active))

# Aggregate our payouts per stashes
summary_our_stashes <- df_total_aggregate %>%
  group_by(our_stash, our_stash_name) %>%
  summarise(sum(our_payoff), sum(our_stake))
colnames(summary_our_stashes) <- c("our_stash", "our_stash_name", "our_payoff", "our_stake")

write.csv(summary_our_stashes, 'summary_our_stashes.csv')
write.csv(summary_validators, 'summary_validators.csv')
